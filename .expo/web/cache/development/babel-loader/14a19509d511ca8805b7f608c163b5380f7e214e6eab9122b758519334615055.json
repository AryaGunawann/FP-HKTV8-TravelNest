{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { useNavigationContainerRef } from \"@react-navigation/native\";\nimport { StatusBar } from \"expo-status-bar\";\nimport React from \"react\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\nimport { getRouteInfoFromState } from \"./LocationProvider\";\nimport UpstreamNavigationContainer from \"./fork/NavigationContainer\";\nimport { getPathDataFromState } from \"./fork/getPathFromState\";\nimport { getLinkingConfig } from \"./getLinkingConfig\";\nimport { getRoutes } from \"./getRoutes\";\nimport { ExpoRouterContext, RootStateContext } from \"./hooks\";\nimport { getQualifiedRouteComponent } from \"./useScreens\";\nimport { SplashScreen } from \"./views/Splash\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-runtime\";\nfunction getGestureHandlerRootView() {\n  try {\n    var _ref = require(\"react-native-gesture-handler\"),\n      _GestureHandlerRootView = _ref.GestureHandlerRootView;\n    return function GestureHandler(props) {\n      return _jsx(_GestureHandlerRootView, _objectSpread({\n        style: {\n          flex: 1\n        }\n      }, props));\n    };\n  } catch (_unused) {\n    return React.Fragment;\n  }\n}\nvar GestureHandlerRootView = getGestureHandlerRootView();\nvar INITIAL_METRICS = {\n  frame: {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  insets: {\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  }\n};\nexport function ExpoRoot(_ref2) {\n  var context = _ref2.context,\n    location = _ref2.location;\n  return _jsx(GestureHandlerRootView, {\n    children: _jsxs(SafeAreaProvider, {\n      initialMetrics: INITIAL_METRICS,\n      children: [_jsx(ContextNavigator, {\n        context: context,\n        location: location\n      }), _jsx(StatusBar, {\n        style: \"auto\"\n      })]\n    })\n  });\n}\nvar initialUrl = Platform.OS === \"web\" && typeof window !== \"undefined\" ? new URL(window.location.href) : undefined;\nfunction ContextNavigator(_ref3) {\n  var context = _ref3.context,\n    _ref3$location = _ref3.location,\n    initialLocation = _ref3$location === void 0 ? initialUrl : _ref3$location;\n  var navigationRef = useNavigationContainerRef();\n  var _React$useState = React.useState(Platform.OS !== \"web\"),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    shouldShowSplash = _React$useState2[0],\n    setShowSplash = _React$useState2[1];\n  var expoContext = React.useMemo(function () {\n    var routeNode = getRoutes(context);\n    var linking = getLinkingConfig(routeNode);\n    var initialState;\n    if (initialLocation) {\n      initialState = linking.getStateFromPath == null ? void 0 : linking.getStateFromPath(initialLocation.pathname + initialLocation.search, linking.config);\n    }\n    function getRouteInfo(state) {\n      return getRouteInfoFromState(function (state, asPath) {\n        return getPathDataFromState(state, _objectSpread(_objectSpread({\n          screens: []\n        }, linking.config), {}, {\n          preserveDynamicRoutes: asPath,\n          preserveGroups: asPath\n        }));\n      }, state);\n    }\n    return {\n      routeNode: routeNode,\n      linking: linking,\n      navigationRef: navigationRef,\n      initialState: initialState,\n      getRouteInfo: getRouteInfo\n    };\n  }, [context, navigationRef, initialLocation]);\n  var routeNode = expoContext.routeNode,\n    initialState = expoContext.initialState,\n    linking = expoContext.linking,\n    getRouteInfo = expoContext.getRouteInfo;\n  var _React$useState3 = React.useState(function () {\n      if (initialState) {\n        return {\n          state: initialState,\n          routeInfo: getRouteInfo(initialState)\n        };\n      } else {\n        return {\n          routeInfo: {\n            unstable_globalHref: \"\",\n            pathname: \"\",\n            params: {},\n            segments: []\n          }\n        };\n      }\n    }),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    rootState = _React$useState4[0],\n    setRootState = _React$useState4[1];\n  React.useEffect(function () {\n    var subscription = navigationRef.addListener(\"state\", function (data) {\n      var state = data.data.state;\n      setRootState({\n        state: state,\n        routeInfo: getRouteInfo(state)\n      });\n    });\n    return function () {\n      return subscription == null ? void 0 : subscription();\n    };\n  }, [navigationRef, getRouteInfo]);\n  if (!routeNode) {\n    if (process.env.NODE_ENV === \"development\") {\n      var Tutorial = require(\"./onboard/Tutorial\").Tutorial;\n      SplashScreen.hideAsync();\n      return _jsx(Tutorial, {});\n    } else {\n      throw new Error(\"No routes found\");\n    }\n  }\n  var Component = getQualifiedRouteComponent(routeNode);\n  return _jsxs(_Fragment, {\n    children: [shouldShowSplash && _jsx(SplashScreen, {}), _jsx(ExpoRouterContext.Provider, {\n      value: expoContext,\n      children: _jsx(UpstreamNavigationContainer, {\n        ref: navigationRef,\n        initialState: initialState,\n        linking: linking,\n        onReady: function onReady() {\n          return requestAnimationFrame(function () {\n            return setShowSplash(false);\n          });\n        },\n        children: _jsx(RootStateContext.Provider, {\n          value: rootState,\n          children: !shouldShowSplash && _jsx(Component, {})\n        })\n      })\n    })]\n  });\n}","map":{"version":3,"names":["useNavigationContainerRef","StatusBar","React","Platform","SafeAreaProvider","getRouteInfoFromState","UpstreamNavigationContainer","getPathDataFromState","getLinkingConfig","getRoutes","ExpoRouterContext","RootStateContext","getQualifiedRouteComponent","SplashScreen","jsx","_jsx","jsxs","_jsxs","Fragment","_Fragment","getGestureHandlerRootView","_ref","require","GestureHandlerRootView","GestureHandler","props","_GestureHandlerRootView","_objectSpread","style","flex","_unused","INITIAL_METRICS","frame","x","y","width","height","insets","top","left","right","bottom","ExpoRoot","_ref2","context","location","children","initialMetrics","ContextNavigator","initialUrl","OS","window","URL","href","undefined","_ref3","_ref3$location","initialLocation","navigationRef","_React$useState","useState","_React$useState2","_slicedToArray","shouldShowSplash","setShowSplash","expoContext","useMemo","routeNode","linking","initialState","getStateFromPath","pathname","search","config","getRouteInfo","state","asPath","screens","preserveDynamicRoutes","preserveGroups","_React$useState3","routeInfo","unstable_globalHref","params","segments","_React$useState4","rootState","setRootState","useEffect","subscription","addListener","data","process","env","NODE_ENV","Tutorial","hideAsync","Error","Component","Provider","value","ref","onReady","requestAnimationFrame"],"sources":["D:/Kampus-Merdeka-Hacktiv8/TravelNest/node_modules/expo-router/src/ExpoRoot.tsx"],"sourcesContent":["import { useNavigationContainerRef } from \"@react-navigation/native\";\nimport { StatusBar } from \"expo-status-bar\";\nimport React from \"react\";\nimport { Platform } from \"react-native\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\n\nimport { getRouteInfoFromState } from \"./LocationProvider\";\nimport UpstreamNavigationContainer from \"./fork/NavigationContainer\";\nimport getPathFromState, {\n  getPathDataFromState,\n} from \"./fork/getPathFromState\";\nimport { ResultState } from \"./fork/getStateFromPath\";\nimport { getLinkingConfig } from \"./getLinkingConfig\";\nimport { getRoutes } from \"./getRoutes\";\nimport {\n  ExpoRouterContextType,\n  ExpoRouterContext,\n  RootStateContext,\n  RootStateContextType,\n  OnboardingExpoRouterContextType,\n} from \"./hooks\";\nimport { RequireContext } from \"./types\";\nimport { getQualifiedRouteComponent } from \"./useScreens\";\nimport { SplashScreen } from \"./views/Splash\";\n\nfunction getGestureHandlerRootView() {\n  try {\n    const { GestureHandlerRootView } =\n      require(\"react-native-gesture-handler\") as typeof import(\"react-native-gesture-handler\");\n\n    return function GestureHandler(props: any) {\n      return <GestureHandlerRootView style={{ flex: 1 }} {...props} />;\n    };\n  } catch {\n    return React.Fragment;\n  }\n}\n\nconst GestureHandlerRootView = getGestureHandlerRootView();\n\nconst INITIAL_METRICS = {\n  frame: { x: 0, y: 0, width: 0, height: 0 },\n  insets: { top: 0, left: 0, right: 0, bottom: 0 },\n};\n\nexport type ExpoRootProps = {\n  context: RequireContext;\n  location?: URL;\n};\n\nexport function ExpoRoot({ context, location }: ExpoRootProps) {\n  return (\n    <GestureHandlerRootView>\n      <SafeAreaProvider\n        // SSR support\n        initialMetrics={INITIAL_METRICS}\n      >\n        <ContextNavigator context={context} location={location} />\n        {/* Users can override this by adding another StatusBar element anywhere higher in the component tree. */}\n        <StatusBar style=\"auto\" />\n      </SafeAreaProvider>\n    </GestureHandlerRootView>\n  );\n}\n\nconst initialUrl =\n  Platform.OS === \"web\" && typeof window !== \"undefined\"\n    ? new URL(window.location.href)\n    : undefined;\n\nfunction ContextNavigator({\n  context,\n  location: initialLocation = initialUrl,\n}: ExpoRootProps) {\n  const navigationRef = useNavigationContainerRef();\n  const [shouldShowSplash, setShowSplash] = React.useState(\n    Platform.OS !== \"web\"\n  );\n\n  const expoContext = React.useMemo<\n    ExpoRouterContextType | OnboardingExpoRouterContextType\n  >(() => {\n    const routeNode = getRoutes(context);\n    const linking = getLinkingConfig(routeNode!);\n    let initialState: ResultState | undefined;\n\n    if (initialLocation) {\n      initialState = linking.getStateFromPath?.(\n        initialLocation.pathname + initialLocation.search,\n        linking.config\n      );\n    }\n\n    function getRouteInfo(state: ResultState) {\n      return getRouteInfoFromState(\n        (state: Parameters<typeof getPathFromState>[0], asPath: boolean) => {\n          return getPathDataFromState(state, {\n            screens: [],\n            ...linking.config,\n            preserveDynamicRoutes: asPath,\n            preserveGroups: asPath,\n          });\n        },\n        state\n      );\n    }\n\n    // This looks redundant but it makes TypeScript correctly infer the union return type.\n    return {\n      routeNode,\n      linking,\n      navigationRef,\n      initialState,\n      getRouteInfo,\n    };\n  }, [context, navigationRef, initialLocation]);\n\n  const { routeNode, initialState, linking, getRouteInfo } = expoContext;\n\n  const [rootState, setRootState] = React.useState<RootStateContextType>(() => {\n    if (initialState) {\n      return {\n        state: initialState,\n        routeInfo: getRouteInfo(initialState),\n      };\n    } else {\n      return {\n        routeInfo: {\n          unstable_globalHref: \"\",\n          pathname: \"\",\n          params: {},\n          segments: [],\n        },\n      };\n    }\n  });\n\n  React.useEffect(() => {\n    const subscription = navigationRef.addListener(\"state\", (data) => {\n      const state = data.data.state as ResultState;\n      setRootState({\n        state,\n        routeInfo: getRouteInfo(state),\n      });\n    });\n\n    return () => subscription?.();\n  }, [navigationRef, getRouteInfo]);\n\n  if (!routeNode) {\n    if (process.env.NODE_ENV === \"development\") {\n      const Tutorial = require(\"./onboard/Tutorial\").Tutorial;\n      SplashScreen.hideAsync();\n      return <Tutorial />;\n    } else {\n      throw new Error(\"No routes found\");\n    }\n  }\n\n  const Component = getQualifiedRouteComponent(routeNode);\n\n  return (\n    <>\n      {shouldShowSplash && <SplashScreen />}\n      <ExpoRouterContext.Provider value={expoContext}>\n        <UpstreamNavigationContainer\n          ref={navigationRef}\n          initialState={initialState}\n          linking={linking}\n          onReady={() => requestAnimationFrame(() => setShowSplash(false))}\n        >\n          <RootStateContext.Provider value={rootState}>\n            {!shouldShowSplash && <Component />}\n          </RootStateContext.Provider>\n        </UpstreamNavigationContainer>\n      </ExpoRouterContext.Provider>\n    </>\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
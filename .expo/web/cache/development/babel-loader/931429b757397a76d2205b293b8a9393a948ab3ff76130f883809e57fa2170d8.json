{"ast":null,"code":"import { CommonActions, getActionFromState, StackActions } from \"@react-navigation/core\";\nimport { TabActions } from \"@react-navigation/routers\";\nimport * as Linking from \"expo-linking\";\nimport * as React from \"react\";\nimport { useExpoRouterContext } from \"../hooks\";\nimport { resolve } from \"./path\";\nimport { findTopRouteForTarget, getEarliestMismatchedRoute, getQualifiedStateForTopOfTargetState, isMovingToSiblingRoute } from \"./stateOperations\";\nfunction isRemoteHref(href) {\n  return /:\\/\\//.test(href);\n}\nexport function useLinkToPath() {\n  var _useExpoRouterContext = useExpoRouterContext(),\n    navigationRef = _useExpoRouterContext.navigationRef,\n    linking = _useExpoRouterContext.linking;\n  var linkTo = React.useCallback(function (href, event) {\n    if (isRemoteHref(href)) {\n      Linking.openURL(href);\n      return;\n    }\n    if (navigationRef == null) {\n      throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n    }\n    if (href === \"..\" || href === \"../\") {\n      navigationRef.goBack();\n      return;\n    }\n    if (href.startsWith(\".\")) {\n      var _linking$getPathFromS;\n      var base = (_linking$getPathFromS = linking.getPathFromState == null ? void 0 : linking.getPathFromState(navigationRef.getRootState(), {\n        screens: [],\n        preserveGroups: true\n      })) != null ? _linking$getPathFromS : \"\";\n      if (base && !base.endsWith(\"/\")) {\n        base += \"/..\";\n      }\n      href = resolve(base, href);\n    }\n    var state = linking.getStateFromPath(href, linking.config);\n    if (!state) {\n      console.error(\"Could not generate a valid navigation state for the given path: \" + href);\n      return;\n    }\n    var rootState = navigationRef.getRootState();\n    if (isMovingToSiblingRoute(rootState, state)) {\n      var knownOwnerState = getQualifiedStateForTopOfTargetState(rootState, state);\n      var nextRoute = findTopRouteForTarget(state);\n      if (knownOwnerState.type === \"tab\") {\n        navigationRef.dispatch(TabActions.jumpTo(nextRoute.name, nextRoute.params));\n        return;\n      } else {\n        if (event === \"REPLACE\") {\n          navigationRef.dispatch(StackActions.replace(nextRoute.name, nextRoute.params));\n        } else {\n          navigationRef.dispatch(CommonActions.navigate(nextRoute.name, nextRoute.params));\n        }\n        return;\n      }\n    }\n    var action = getActionFromState(state, linking.config);\n    if (action) {\n      if (event === \"REPLACE\" && isAbsoluteInitialRoute(action)) {\n        var earliest = getEarliestMismatchedRoute(rootState, action.payload);\n        if (earliest) {\n          if (earliest.type === \"stack\") {\n            navigationRef.dispatch(StackActions.replace(earliest.name, earliest.params));\n          } else {\n            navigationRef.dispatch(TabActions.jumpTo(earliest.name, earliest.params));\n          }\n          return;\n        } else {}\n      }\n      navigationRef.dispatch(action);\n    } else {\n      navigationRef.reset(state);\n    }\n  }, [linking, navigationRef]);\n  return linkTo;\n}\nexport function isAbsoluteInitialRoute(action) {\n  if ((action == null ? void 0 : action.type) !== \"NAVIGATE\") {\n    return false;\n  }\n  var next = action.payload.params;\n  while (next) {\n    if (!isNavigationState(next)) {\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isNavigationState(obj) {\n  return \"initial\" in obj;\n}","map":{"version":3,"names":["CommonActions","getActionFromState","StackActions","TabActions","Linking","React","useExpoRouterContext","resolve","findTopRouteForTarget","getEarliestMismatchedRoute","getQualifiedStateForTopOfTargetState","isMovingToSiblingRoute","isRemoteHref","href","test","useLinkToPath","_useExpoRouterContext","navigationRef","linking","linkTo","useCallback","event","openURL","Error","goBack","startsWith","_linking$getPathFromS","base","getPathFromState","getRootState","screens","preserveGroups","endsWith","state","getStateFromPath","config","console","error","rootState","knownOwnerState","nextRoute","type","dispatch","jumpTo","name","params","replace","navigate","action","isAbsoluteInitialRoute","earliest","payload","reset","next","isNavigationState","initial","obj"],"sources":["D:/Kampus-Merdeka-Hacktiv8/TravelNest/node_modules/expo-router/src/link/useLinkToPath.ts"],"sourcesContent":["import {\n  CommonActions,\n  getActionFromState,\n  StackActions,\n} from \"@react-navigation/core\";\nimport { TabActions } from \"@react-navigation/routers\";\nimport * as Linking from \"expo-linking\";\nimport * as React from \"react\";\n\nimport { useExpoRouterContext } from \"../hooks\";\nimport { resolve } from \"./path\";\nimport {\n  findTopRouteForTarget,\n  getEarliestMismatchedRoute,\n  getQualifiedStateForTopOfTargetState,\n  isMovingToSiblingRoute,\n  NavigateAction,\n} from \"./stateOperations\";\n\ntype NavStateParams = {\n  params?: NavStateParams;\n  path: string;\n  initial: boolean;\n  screen: string;\n  state: unknown;\n};\n\nfunction isRemoteHref(href: string): boolean {\n  return /:\\/\\//.test(href);\n}\n\nexport function useLinkToPath() {\n  const { navigationRef, linking } = useExpoRouterContext();\n\n  const linkTo = React.useCallback(\n    (href: string, event?: string) => {\n      if (isRemoteHref(href)) {\n        Linking.openURL(href);\n        return;\n      }\n\n      if (navigationRef == null) {\n        throw new Error(\n          \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n        );\n      }\n\n      if (href === \"..\" || href === \"../\") {\n        navigationRef.goBack();\n        return;\n      }\n\n      if (href.startsWith(\".\")) {\n        let base =\n          linking.getPathFromState?.(navigationRef.getRootState(), {\n            screens: [],\n            preserveGroups: true,\n          }) ?? \"\";\n\n        if (base && !base.endsWith(\"/\")) {\n          base += \"/..\";\n        }\n        href = resolve(base, href);\n      }\n\n      const state = linking.getStateFromPath!(href, linking!.config);\n\n      if (!state) {\n        console.error(\n          \"Could not generate a valid navigation state for the given path: \" +\n            href\n        );\n        return;\n      }\n\n      const rootState = navigationRef.getRootState();\n\n      // Ensure simple operations are used when moving between siblings\n      // in the same navigator. This ensures that the state is not reset.\n      // TODO: We may need to apply this at a larger scale in the future.\n      if (isMovingToSiblingRoute(rootState, state)) {\n        // Can perform naive movements\n        const knownOwnerState = getQualifiedStateForTopOfTargetState(\n          rootState,\n          state\n        )!;\n        const nextRoute = findTopRouteForTarget(state);\n\n        if (knownOwnerState.type === \"tab\") {\n          navigationRef.dispatch(\n            TabActions.jumpTo(nextRoute.name, nextRoute.params)\n          );\n          return;\n        } else {\n          if (event === \"REPLACE\") {\n            navigationRef.dispatch(\n              StackActions.replace(nextRoute.name, nextRoute.params)\n            );\n          } else {\n            // NOTE: Not sure if we should pop or push here...\n            navigationRef.dispatch(\n              CommonActions.navigate(nextRoute.name, nextRoute.params)\n            );\n          }\n          return;\n        }\n      }\n\n      // TODO: Advanced movements across multiple navigators\n\n      const action = getActionFromState(state, linking!.config);\n      if (action) {\n        // Here we have a navigation action to a nested screen, where we should ideally replace.\n        // This request can only be fulfilled if the target is an initial route.\n        // First, check if the action is fully initial routes.\n        // Then find the nearest mismatched route in the existing state.\n        // Finally, use the correct navigator-based action to replace the nested screens.\n        // NOTE(EvanBacon): A future version of this will involve splitting the navigation request so we replace as much as possible, then push the remaining screens to fulfill the request.\n        if (event === \"REPLACE\" && isAbsoluteInitialRoute(action)) {\n          const earliest = getEarliestMismatchedRoute(\n            rootState,\n            action.payload\n          );\n          if (earliest) {\n            if (earliest.type === \"stack\") {\n              navigationRef.dispatch(\n                StackActions.replace(earliest.name, earliest.params)\n              );\n            } else {\n              navigationRef.dispatch(\n                TabActions.jumpTo(earliest.name, earliest.params)\n              );\n            }\n            return;\n          } else {\n            // This should never happen because moving to the same route would be handled earlier\n            // in the sibling operations.\n          }\n        }\n\n        // Ignore the replace event here since replace across\n        // navigators is not supported.\n        navigationRef.dispatch(action);\n      } else {\n        navigationRef.reset(state);\n      }\n    },\n    [linking, navigationRef]\n  );\n\n  return linkTo;\n}\n\n/** @returns `true` if the action is moving to the first screen of all the navigators in the action. */\nexport function isAbsoluteInitialRoute(\n  action: ReturnType<typeof getActionFromState>\n): action is NavigateAction {\n  if (action?.type !== \"NAVIGATE\") {\n    return false;\n  }\n\n  let next = action.payload.params;\n  // iterate all child screens and bail out if any are not initial.\n  while (next) {\n    if (!isNavigationState(next)) {\n      // Not sure when this would happen\n      return false;\n    }\n    if (next.initial === true) {\n      next = next.params;\n      // return true;\n    } else if (next.initial === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isNavigationState(obj: any): obj is NavStateParams {\n  return \"initial\" in obj;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
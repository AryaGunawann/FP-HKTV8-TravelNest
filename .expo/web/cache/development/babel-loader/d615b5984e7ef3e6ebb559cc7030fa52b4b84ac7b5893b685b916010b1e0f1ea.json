{"ast":null,"code":"import { NavigationRouteContext } from \"@react-navigation/native\";\nimport React from \"react\";\nexport var ExpoRouterContext = React.createContext(undefined);\nexport var RootStateContext = React.createContext({});\nexport function useRootNavigationState() {\n  return React.useContext(RootStateContext);\n}\nexport function useRouteInfo() {\n  return React.useContext(RootStateContext).routeInfo;\n}\nexport function useExpoRouterContext() {\n  return React.useContext(ExpoRouterContext);\n}\nexport function useRootNavigation() {\n  var _useExpoRouterContext = useExpoRouterContext(),\n    navigationRef = _useExpoRouterContext.navigationRef;\n  return navigationRef.current;\n}\nexport function useLinkingContext() {\n  return useExpoRouterContext().linking;\n}\nexport function useUnstableGlobalHref() {\n  return useRouteInfo().unstable_globalHref;\n}\nexport function useSegments() {\n  return useRouteInfo().segments;\n}\nexport function usePathname() {\n  return useRouteInfo().pathname;\n}\nexport function useGlobalSearchParams() {\n  return useRouteInfo().params;\n}\nexport function useSearchParams() {\n  return useGlobalSearchParams();\n}\nexport function useLocalSearchParams() {\n  var _useOptionalLocalRout, _useOptionalLocalRout2;\n  return (_useOptionalLocalRout = (_useOptionalLocalRout2 = useOptionalLocalRoute()) == null ? void 0 : _useOptionalLocalRout2.params) != null ? _useOptionalLocalRout : {};\n}\nfunction useOptionalLocalRoute() {\n  var route = React.useContext(NavigationRouteContext);\n  return route;\n}","map":{"version":3,"names":["NavigationRouteContext","React","ExpoRouterContext","createContext","undefined","RootStateContext","useRootNavigationState","useContext","useRouteInfo","routeInfo","useExpoRouterContext","useRootNavigation","_useExpoRouterContext","navigationRef","current","useLinkingContext","linking","useUnstableGlobalHref","unstable_globalHref","useSegments","segments","usePathname","pathname","useGlobalSearchParams","params","useSearchParams","useLocalSearchParams","_useOptionalLocalRout","_useOptionalLocalRout2","useOptionalLocalRoute","route"],"sources":["D:/Kampus-Merdeka-Hacktiv8/TravelNest/node_modules/expo-router/src/hooks.ts"],"sourcesContent":["import {\n  NavigationContainerRefWithCurrent,\n  NavigationRouteContext,\n  ParamListBase,\n  RouteProp,\n} from \"@react-navigation/native\";\nimport React from \"react\";\n\nimport { UrlObject } from \"./LocationProvider\";\nimport { RouteNode } from \"./Route\";\nimport { ResultState } from \"./fork/getStateFromPath\";\nimport { ExpoLinkingOptions } from \"./getLinkingConfig\";\n\ntype SearchParams = Record<string, string | string[]>;\n\nexport type ExpoRouterContextType = {\n  routeNode: RouteNode;\n  linking: ExpoLinkingOptions;\n  navigationRef: NavigationContainerRefWithCurrent<ReactNavigation.RootParamList>;\n  initialState: ResultState | undefined;\n  getRouteInfo: (state: ResultState) => UrlObject;\n};\n\n// If there is no routeNode we should show the onboarding screen\nexport type OnboardingExpoRouterContextType = Omit<\n  ExpoRouterContextType,\n  \"routeNode\"\n> & { routeNode: null };\n\nexport const ExpoRouterContext = React.createContext<\n  ExpoRouterContextType | undefined\n>(undefined);\n\nexport type RootStateContextType = {\n  state?: ResultState;\n  routeInfo?: UrlObject;\n};\n\nexport const RootStateContext = React.createContext<RootStateContextType>({});\n\nexport function useRootNavigationState() {\n  return React.useContext(RootStateContext);\n}\n\nexport function useRouteInfo() {\n  return React.useContext(RootStateContext).routeInfo!;\n}\n\nexport function useExpoRouterContext() {\n  return React.useContext(ExpoRouterContext)!;\n}\n\nexport function useRootNavigation() {\n  const { navigationRef } = useExpoRouterContext();\n  return navigationRef.current;\n}\n\nexport function useLinkingContext() {\n  return useExpoRouterContext().linking;\n}\n\n/**\n * @private\n * @returns the current global pathname with query params attached. This may change in the future to include the hostname from a predefined universal link, i.e. `/foobar?hey=world` becomes `https://acme.dev/foobar?hey=world`\n */\nexport function useUnstableGlobalHref(): string {\n  return useRouteInfo().unstable_globalHref;\n}\n\n/**\n * Get a list of selected file segments for the currently selected route. Segments are not normalized, so they will be the same as the file path. e.g. /[id]?id=normal -> [\"[id]\"]\n *\n * `useSegments` can be typed using an abstract.\n * Consider the following file structure, and strictly typed `useSegments` function:\n *\n * ```md\n * - app\n *   - [user]\n *     - index.js\n *     - followers.js\n *   - settings.js\n * ```\n * This can be strictly typed using the following abstract:\n *\n * ```ts\n * const [first, second] = useSegments<['settings'] | ['[user]'] | ['[user]', 'followers']>()\n * ```\n */\nexport function useSegments<\n  TSegments extends string[] = string[]\n>(): TSegments {\n  return useRouteInfo().segments as TSegments;\n}\n\n/** @returns global selected pathname without query parameters. */\nexport function usePathname(): string {\n  return useRouteInfo().pathname;\n}\n\n/**\n * Get the globally selected query parameters, including dynamic path segments. This function will update even when the route is not focused.\n * Useful for analytics or other background operations that don't draw to the screen.\n *\n * When querying search params in a stack, opt-towards using `useLocalSearchParams` as these will only\n * update when the route is focused.\n *\n * @see `useLocalSearchParams`\n */\nexport function useGlobalSearchParams<\n  TParams extends SearchParams = SearchParams\n>(): Partial<TParams> {\n  return useRouteInfo().params as Partial<TParams>;\n}\n\n/** @deprecated renamed to `useGlobalSearchParams` */\nexport function useSearchParams<\n  TParams extends SearchParams = SearchParams\n>(): Partial<TParams> {\n  return useGlobalSearchParams<TParams>();\n}\n\n/**\n * Returns the URL search parameters for the contextually focused route. e.g. `/acme?foo=bar` -> `{ foo: \"bar\" }`.\n * This is useful for stacks where you may push a new screen that changes the query parameters.\n *\n * To observe updates even when the invoking route is not focused, use `useGlobalSearchParams()`.\n */\nexport function useLocalSearchParams<\n  TParams extends SearchParams = SearchParams\n>(): Partial<TParams> {\n  return (useOptionalLocalRoute()?.params ?? ({} as any)) as Partial<TParams>;\n}\n\nfunction useOptionalLocalRoute<T extends RouteProp<ParamListBase>>():\n  | T\n  | undefined {\n  const route = React.useContext(NavigationRouteContext);\n  return route as T | undefined;\n}\n"],"mappings":"AAAA,SAEEA,sBAAsB,QAGjB,0BAA0B;AACjC,OAAOC,KAAK,MAAM,OAAO;AAuBzB,OAAO,IAAMC,iBAAiB,GAAGD,KAAK,CAACE,aAAa,CAElDC,SAAS,CAAC;AAOZ,OAAO,IAAMC,gBAAgB,GAAGJ,KAAK,CAACE,aAAa,CAAuB,CAAC,CAAC,CAAC;AAE7E,OAAO,SAASG,sBAAsBA,CAAA,EAAG;EACvC,OAAOL,KAAK,CAACM,UAAU,CAACF,gBAAgB,CAAC;AAC3C;AAEA,OAAO,SAASG,YAAYA,CAAA,EAAG;EAC7B,OAAOP,KAAK,CAACM,UAAU,CAACF,gBAAgB,CAAC,CAACI,SAAS;AACrD;AAEA,OAAO,SAASC,oBAAoBA,CAAA,EAAG;EACrC,OAAOT,KAAK,CAACM,UAAU,CAACL,iBAAiB,CAAC;AAC5C;AAEA,OAAO,SAASS,iBAAiBA,CAAA,EAAG;EAClC,IAAAC,qBAAA,GAA0BF,oBAAoB,CAAC,CAAC;IAAxCG,aAAa,GAAAD,qBAAA,CAAbC,aAAa;EACrB,OAAOA,aAAa,CAACC,OAAO;AAC9B;AAEA,OAAO,SAASC,iBAAiBA,CAAA,EAAG;EAClC,OAAOL,oBAAoB,CAAC,CAAC,CAACM,OAAO;AACvC;AAMA,OAAO,SAASC,qBAAqBA,CAAA,EAAW;EAC9C,OAAOT,YAAY,CAAC,CAAC,CAACU,mBAAmB;AAC3C;AAqBA,OAAO,SAASC,WAAWA,CAAA,EAEZ;EACb,OAAOX,YAAY,CAAC,CAAC,CAACY,QAAQ;AAChC;AAGA,OAAO,SAASC,WAAWA,CAAA,EAAW;EACpC,OAAOb,YAAY,CAAC,CAAC,CAACc,QAAQ;AAChC;AAWA,OAAO,SAASC,qBAAqBA,CAAA,EAEf;EACpB,OAAOf,YAAY,CAAC,CAAC,CAACgB,MAAM;AAC9B;AAGA,OAAO,SAASC,eAAeA,CAAA,EAET;EACpB,OAAOF,qBAAqB,CAAU,CAAC;AACzC;AAQA,OAAO,SAASG,oBAAoBA,CAAA,EAEd;EAAA,IAAAC,qBAAA,EAAAC,sBAAA;EACpB,QAAAD,qBAAA,IAAAC,sBAAA,GAAQC,qBAAqB,CAAC,CAAC,qBAAvBD,sBAAA,CAAyBJ,MAAM,YAAAG,qBAAA,GAAK,CAAC,CAAC;AAChD;AAEA,SAASE,qBAAqBA,CAAA,EAEhB;EACZ,IAAMC,KAAK,GAAG7B,KAAK,CAACM,UAAU,CAACP,sBAAsB,CAAC;EACtD,OAAO8B,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}